
<!DOCTYPE html
  PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">
<html><head>
      <meta http-equiv="Content-Type" content="text/html; charset=utf-8">
   <!--
This HTML was auto-generated from MATLAB code.
To make changes, update the MATLAB code and republish this document.
      --><title>crossovers documentation</title><meta name="generator" content="MATLAB 8.0"><link rel="schema.DC" href="http://purl.org/dc/elements/1.1/"><meta name="DC.date" content="2017-05-22"><meta name="DC.source" content="crossovers_documentation.m"><style type="text/css">
html,body,div,span,applet,object,iframe,h1,h2,h3,h4,h5,h6,p,blockquote,pre,a,abbr,acronym,address,big,cite,code,del,dfn,em,font,img,ins,kbd,q,s,samp,small,strike,strong,sub,sup,tt,var,b,u,i,center,dl,dt,dd,ol,ul,li,fieldset,form,label,legend,table,caption,tbody,tfoot,thead,tr,th,td{margin:0;padding:0;border:0;outline:0;font-size:100%;vertical-align:baseline;background:transparent}body{line-height:1}ol,ul{list-style:none}blockquote,q{quotes:none}blockquote:before,blockquote:after,q:before,q:after{content:'';content:none}:focus{outine:0}ins{text-decoration:none}del{text-decoration:line-through}table{border-collapse:collapse;border-spacing:0}

html { min-height:100%; margin-bottom:1px; }
html body { height:100%; margin:0px; font-family:Arial, Helvetica, sans-serif; font-size:10px; color:#000; line-height:140%; background:#fff none; overflow-y:scroll; }
html body td { vertical-align:top; text-align:left; }

h1 { padding:0px; margin:0px 0px 25px; font-family:Arial, Helvetica, sans-serif; font-size:1.5em; color:#d55000; line-height:100%; font-weight:normal; }
h2 { padding:0px; margin:0px 0px 8px; font-family:Arial, Helvetica, sans-serif; font-size:1.2em; color:#000; font-weight:bold; line-height:140%; border-bottom:1px solid #d6d4d4; display:block; }
h3 { padding:0px; margin:0px 0px 5px; font-family:Arial, Helvetica, sans-serif; font-size:1.1em; color:#000; font-weight:bold; line-height:140%; }

a { color:#005fce; text-decoration:none; }
a:hover { color:#005fce; text-decoration:underline; }
a:visited { color:#004aa0; text-decoration:none; }

p { padding:0px; margin:0px 0px 20px; }
img { padding:0px; margin:0px 0px 20px; border:none; }
p img, pre img, tt img, li img { margin-bottom:0px; } 

ul { padding:0px; margin:0px 0px 20px 23px; list-style:square; }
ul li { padding:0px; margin:0px 0px 7px 0px; }
ul li ul { padding:5px 0px 0px; margin:0px 0px 7px 23px; }
ul li ol li { list-style:decimal; }
ol { padding:0px; margin:0px 0px 20px 0px; list-style:decimal; }
ol li { padding:0px; margin:0px 0px 7px 23px; list-style-type:decimal; }
ol li ol { padding:5px 0px 0px; margin:0px 0px 7px 0px; }
ol li ol li { list-style-type:lower-alpha; }
ol li ul { padding-top:7px; }
ol li ul li { list-style:square; }

.content { font-size:1.2em; line-height:140%; padding: 20px; }

pre, tt, code { font-size:12px; }
pre { margin:0px 0px 20px; }
pre.error { color:red; }
pre.codeinput { padding:10px; border:1px solid #d3d3d3; background:#f7f7f7; }
pre.codeoutput { padding:10px 11px; margin:0px 0px 20px; color:#4c4c4c; }

@media print { pre.codeinput, pre.codeoutput { word-wrap:break-word; width:100%; } }

span.keyword { color:#0000FF }
span.comment { color:#228B22 }
span.string { color:#A020F0 }
span.untermstring { color:#B20000 }
span.syscmd { color:#B28C00 }

.footer { width:auto; padding:10px 0px; margin:25px 0px 0px; border-top:1px dotted #878787; font-size:0.8em; line-height:140%; font-style:italic; color:#878787; text-align:left; float:none; }
.footer p { margin:0px; }
.footer a { color:#878787; }
.footer a:hover { color:#878787; text-decoration:underline; }
.footer a:visited { color:#878787; }

table th { padding:7px 5px; text-align:left; vertical-align:middle; border: 1px solid #d6d4d4; font-weight:bold; }
table td { padding:7px 5px; text-align:left; vertical-align:top; border:1px solid #d6d4d4; }





  </style></head><body><div class="content"><h1><tt>crossovers</tt> documentation</h1><!--introduction--><p><tt>crossovers</tt> is part of Antarctic Mapping Tools for Matlab (Greene et al., 2017). Click <a href="List_of_functions.html">here</a> for a complete list of functions in AMT.</p><p>The <tt>crossovers</tt> function efficiently finds crossover locations of georeferenced or polar stereographic coordinates. This function works for self-intesecting flight lines or multiple flight lines concatenated into a single array.</p><!--/introduction--><h2>Contents</h2><div><ul><li><a href="#1">Syntax</a></li><li><a href="#2">Description</a></li><li><a href="#3"><tt>crossovers</tt> versus <tt>pathcrossingsps71</tt></a></li><li><a href="#4">Example: Plot data</a></li><li><a href="#5">Example: Find all crossover locations</a></li><li><a href="#6">Example: Limit crossovers to given conditions</a></li><li><a href="#7">Example: Estimation of errors</a></li><li><a href="#9">Citing AMT</a></li><li><a href="#10">Author Info:</a></li></ul></div><h2>Syntax<a name="1"></a></h2><pre>[xi,yi] = crossovers(x,y)
[lati,loni] = crossovers(lat,lon)
[...,zi,ti] = crossovers(...,z,t)
[...] = crossovers(...,'maxdt',max_time_diff)
[...] = crossovers(...,'mindt',min_time_diff)
[...] = crossovers(...,'maxdist',max_distance)
[...] = crossovers(...,'inrange',latlim_or_xlim,lonlim_or_ylim)
[...] = crossovers(...,'tile',TilePreference)
[...] = crossovers(...,'interp',InterpolationMethod)</pre><h2>Description<a name="2"></a></h2><p><tt>[xi,yi] = crossovers(x,y)</tt> returns location(s) of crossover points in the arrays x,y, where <tt>x</tt> and <tt>y</tt> are polar stereographic (ref -71) coordinates. x and y must be column vectors.</p><p><tt>[lati,loni] = crossovers(lat,lon)</tt> returns georeferenced location(s) of crossovers if inputs are geo coordinates. Geo coordinates are assumed if no element in the first argument has an absolute value greater than 90 and no element in the second argument has an absolute value greater than 360. <tt>lat</tt> and <tt>lon</tt> must be column vectors.</p><p><tt>[...,zi,ti] = crossovers(...,z,t)</tt> returns elevations and times of crossovers. <tt>zi</tt> and <tt>ti</tt> are both two-column vectors whose first column corresponds to the elevation and time of the first measurement in time, and column 2 corresponds to the second pass. Elevation change at crossovers dzi/dti may be calculated as <tt>diff(zi,1,2)./diff(ti,1,2)</tt>.</p><p><tt>[...] = crossovers(...,'maxdt',max_time_diff)</tt> limits results to crossovers separated in time by less than or equal to max_time_diff. Using a max_time_diff value of 150 is one way of considering only crossovers from the same field campaign year.  Units of <tt>max_time_diff</tt> are days.</p><p><tt>[...] = crossovers(...,'mindt',min_time_diff)</tt> limits results to crossovers separated in time by at least min_time_diff. Using <tt>min_time_diff = 1/96</tt> (15 minutes, that is) is one way to prevent the intersection-finding function from getting confused. Units of <tt>min_time_diff</tt> are days.</p><p><tt>[...] = crossovers(...,'maxdist',max_distance)</tt> limits results to crossovers that are within max_distance meters of the nearest measurement in both passes. Using <tt>max_distance = 100</tt> ensures that every value in <tt>(xi,yi)</tt> or <tt>(lati,loni)</tt> lies within 100 meters of a measurement from pass 1 and pass 2.</p><p><tt>[...] = crossovers(...,'inrange',latlim_or_xlim,lonlim_or_ylim)</tt> limits analysis to a subset geoquad or polar stereographic bounding box. If input locations are geo coordinates, bounding limits are assumed to be geo coordinates.  If inputs coordinates are polar stereographic meters, xlim and ylim are assumed.  For example, <tt>crossovers(lat,lon,'inrange',[-70 -65],[110 115])</tt> subsets <tt>lat,lon</tt> to the geoquad given by 70&deg;S to 65&deg;S and 110&deg;E to 115&deg;E.</p><p><tt>[...] = crossovers(...,'tile',TilePreference)</tt> specifies a solver setting as <tt>'on'</tt>, <tt>'off'</tt>, or <tt>'auto'</tt>. For inputs of more than 15,000 points, calculating path intersections all at once with tiling off crashes my computer. This function is designed to intelligently solve sections at a time by breaking the domain into multiple tiles.  Default <tt>TilePreference</tt> is <tt>'auto'</tt>.</p><p><tt>[...] = crossovers(...,'interp',InterpolationMethod)</tt> specifies method of interpolation for <tt>zi</tt> and <tt>ti</tt>. Default method is <tt>'linear'</tt>, but you may also choose <tt>'cubic'</tt>. Cubic interpolation requires more points in each direction and it's very slightly slower than linear.</p><h2><tt>crossovers</tt> versus <tt>pathcrossingsps71</tt><a name="3"></a></h2><p>The <tt>crossovers</tt> function is similar to another tool in the Antarctic Mapping Tools package, <a href="http://www.mathworks.com/matlabcentral/fileexchange/47638-antarctic-mapping-tools/content/AntarcticMappingTools/Documentation/html/pathcrossingps71_documentation.html"><tt>pathcrossingsps71</tt></a>. Here are the differences:</p><div><ul><li><b><tt>pathcrossingsps71</tt></b> finds intersections between two separate datasets, say a grounding line and a flight line. <tt>pathcrossingsps71</tt> is preferred when you do not want to find self intersections and/or when data are not linked to temporal information.</li><li><b><tt>crossovers</tt></b> finds self intersections within the same flight line. <tt>crossovers</tt> is more computationally efficient than <tt>pathcrossingsps71</tt> and offers options for limiting temporal and spatial separation.</li></ul></div><h2>Example: Plot data<a name="4"></a></h2><p>Consider a self-intersecting flight line of ~9000 data points. The Antarctic Mapping Tools package includes a sample flight line dataset called <tt>samplegrid</tt>. Let's take a look. Start by making a 50 km wide <a href="http://www.mathworks.com/matlabcentral/fileexchange/47282-modis-mosaic-of-antarctica/content//html/modismoa_demo.html"><tt>modismoa</tt></a> map centered on the data points.  Specify low contrast to prevent the background image from being too visually busy.  Below I'm using my <a href="http://www.mathworks.com/matlabcentral/fileexchange/46872-intuitive-rgb-color-values-from-xkcd/content//demo/html/rgb_demo.html"><tt>rgb</tt></a> function to get RGB values of light blue and dark blue.</p><pre class="codeinput"><span class="comment">% Load sample data:</span>
load <span class="string">samplegrid</span>

<span class="comment">% Zoom a map to the region of interest:</span>
mapzoomps(mean(lat),mean(lon),<span class="string">'mapwidth'</span>,50)

<span class="comment">% Plot a low-contrast MODIS MOA image:</span>
modismoaps(<span class="string">'contrast'</span>,<span class="string">'low'</span>)

<span class="comment">% Plot the flight line:</span>
plotps(lat,lon,<span class="string">'.'</span>,<span class="string">'color'</span>,rgb(<span class="string">'light blue'</span>))

<span class="comment">% Add a scalebar:</span>
scalebarps(<span class="string">'length'</span>,10)
</pre><img vspace="5" hspace="5" src="crossovers_documentation_01.png" alt=""> <h2>Example: Find all crossover locations<a name="5"></a></h2><p>To find all crossover locations the syntax is easy:</p><pre class="codeinput">[latc,lonc] = crossovers(lat,lon);
plotps(latc,lonc,<span class="string">'o'</span>,<span class="string">'color'</span>,rgb(<span class="string">'dark blue'</span>))
</pre><img vspace="5" hspace="5" src="crossovers_documentation_02.png" alt=""> <h2>Example: Limit crossovers to given conditions<a name="6"></a></h2><p>Sometimes you may want to specify conditions for crossovers.  Often times we want to filter out processes that take place on short or long time scales.  Here let's say we only want crossovers where the different legs of the flight were more than one hour apart and less than 2.5 hours apart.  Further, we want to make sure that each crossover location lies within 45 meters of a measurement on <i>each</i> leg of the crossover:</p><pre class="codeinput">[latc,lonc,zc] = crossovers(lat,lon,z,t,<span class="keyword">...</span>
    <span class="string">'mindt'</span>,1/24,<span class="keyword">...</span><span class="comment">   % crossovers separated by &gt; 1 hr</span>
    <span class="string">'maxdt'</span>,2.5/24,<span class="keyword">...</span><span class="comment"> % crossovers separated by &lt; 2.5 hrs</span>
    <span class="string">'maxdist'</span>,45,<span class="keyword">...</span><span class="comment">   % within 45 m of a measurement</span>
    <span class="string">'interp'</span>,<span class="string">'cubic'</span>); <span class="comment">% use cubic interpolation</span>

plotps(latc,lonc,<span class="string">'go'</span>,<span class="string">'markerfacecolor'</span>,<span class="string">'r'</span>)
</pre><img vspace="5" hspace="5" src="crossovers_documentation_03.png" alt=""> <h2>Example: Estimation of errors<a name="7"></a></h2><p>A common way to quantify measurement errors is to look at the difference between measurements at crossover locations.  Above we calculated <tt>zc</tt>, which is a 45x2 matrix of elevations at each of the 45 crossover locations. Column 1 contains elevations at crossover locations for the first leg of each crossover and column 2 contains elevations for the second leg of each crossover. In this example we should expect very little change in surface elevation to take place on this grounded ice in less than 2.5 hours, so we take the difference between column 1 and column 2 of <tt>zc</tt> as an estimate of measurement error:</p><pre class="codeinput">zerror = zc(:,2)-zc(:,1);

figure
hist(100*abs(zerror),0:10:100)
box <span class="string">off</span>
xlabel <span class="string">'crossover | \Deltaz | (cm)'</span>
title([<span class="string">'standard deviation of error = '</span>,sprintf(<span class="string">'%2.f'</span>,std(100*zerror)),<span class="string">' cm'</span>])
</pre><img vspace="5" hspace="5" src="crossovers_documentation_04.png" alt=""> <p>A standard deviation of 43 cm is pretty close to what we'd expect--the <tt>samplegrid</tt> data file contains elevations that were obtained by adding 40-cm gaussian noise to Bedmap2 data.</p><h2>Citing AMT<a name="9"></a></h2><p>If this function or any other part of Antarctic Mapping Tools is useful for you, please cite the paper that describes AMT.</p><p>Greene, C. A., Gwyther, D. E., &amp; Blankenship, D. D. Antarctic Mapping Tools for Matlab. <i>Computers &amp; Geosciences</i>. 104 (2017) pp.151-157. <a href="http://dx.doi.org/10.1016/j.cageo.2016.08.003">doi:10.1016/j.cageo.2016.08.003</a>.</p><h2>Author Info:<a name="10"></a></h2><p>The <tt>crossovers</tt> function, supporting documentation, and the Antarctic Mapping Tools package were written by <a href="http://www.chadagreene">Chad A. Greene</a> of The University of Texas at Austin's Institute for Geophysics, June 2015. This function includes Douglas M. Schwarz's <a href="http://www.mathworks.com/matlabcentral/fileexchange/11837"><tt>intersections</tt></a> function as a subfunction.</p><p class="footer"><br><a href="http://www.mathworks.com/products/matlab/">Published with MATLAB&reg; R2012b</a><br></p></div><!--
##### SOURCE BEGIN #####
%% |crossovers| documentation 
% |crossovers| is part of Antarctic Mapping Tools for Matlab (Greene et al., 2017). Click <List_of_functions.html here>
% for a complete list of functions in AMT. 
% 
% The |crossovers| function efficiently finds crossover locations of georeferenced or polar stereographic 
% coordinates. This function works for self-intesecting flight lines or
% multiple flight lines concatenated into a single array. 
% 
%% Syntax
% 
%  [xi,yi] = crossovers(x,y) 
%  [lati,loni] = crossovers(lat,lon)
%  [...,zi,ti] = crossovers(...,z,t)
%  [...] = crossovers(...,'maxdt',max_time_diff)
%  [...] = crossovers(...,'mindt',min_time_diff)
%  [...] = crossovers(...,'maxdist',max_distance)
%  [...] = crossovers(...,'inrange',latlim_or_xlim,lonlim_or_ylim)
%  [...] = crossovers(...,'tile',TilePreference)
%  [...] = crossovers(...,'interp',InterpolationMethod)
% 
%% Description
% 
% |[xi,yi] = crossovers(x,y)| returns location(s) of crossover points in the arrays x,y, 
% where |x| and |y| are polar stereographic (ref -71) coordinates. x and y must be column 
% vectors.  
%
% |[lati,loni] = crossovers(lat,lon)| returns georeferenced location(s) of crossovers
% if inputs are geo coordinates. Geo coordinates are assumed if no
% element in the first argument has an absolute value greater than 90 and no element  
% in the second argument has an absolute value greater than 360. |lat| and |lon| must 
% be column vectors. 
% 
% |[...,zi,ti] = crossovers(...,z,t)| returns elevations and times of crossovers. |zi| and |ti|
% are both two-column vectors whose first column corresponds to the elevation and time of
% the first measurement in time, and column 2 corresponds to the second pass. Elevation 
% change at crossovers dzi/dti may be calculated as |diff(zi,1,2)./diff(ti,1,2)|.  
%
% |[...] = crossovers(...,'maxdt',max_time_diff)| limits results to crossovers separated in time 
% by less than or equal to max_time_diff. Using a max_time_diff value of 150 is one way
% of considering only crossovers from the same field campaign year.  Units
% of |max_time_diff| are days. 
% 
% |[...] = crossovers(...,'mindt',min_time_diff)| limits results to crossovers separated in time
% by at least min_time_diff. Using |min_time_diff = 1/96| (15 minutes, that is) is one way
% to prevent the intersection-finding function from getting confused. Units of |min_time_diff|
% are days. 
% 
% |[...] = crossovers(...,'maxdist',max_distance)| limits results to crossovers that are within 
% max_distance meters of the nearest measurement in both passes. Using |max_distance = 100| 
% ensures that every value in |(xi,yi)| or |(lati,loni)| lies within 100 meters of a measurement 
% from pass 1 and pass 2.  
% 
% |[...] = crossovers(...,'inrange',latlim_or_xlim,lonlim_or_ylim)| limits analysis to a subset
% geoquad or polar stereographic bounding box. If input locations are geo coordinates, bounding
% limits are assumed to be geo coordinates.  If inputs coordinates are polar stereographic meters, 
% xlim and ylim are assumed.  For example, |crossovers(lat,lon,'inrange',[-70 -65],[110 115])| 
% subsets |lat,lon| to the geoquad given by 70째S to 65째S and 110째E to 115째E.   
% 
% |[...] = crossovers(...,'tile',TilePreference)| specifies a solver setting as |'on'|, |'off'|, or 
% |'auto'|. For inputs of more than 15,000 points, calculating path intersections all at once with
% tiling off crashes my computer. This function is designed to intelligently solve sections at
% a time by breaking the domain into multiple tiles.  Default |TilePreference| is |'auto'|.   
% 
% |[...] = crossovers(...,'interp',InterpolationMethod)| specifies method of interpolation for  
% |zi| and |ti|. Default method is |'linear'|, but you may also choose |'cubic'|. Cubic interpolation
% requires more points in each direction and it's very slightly slower than linear.  
% 
%% |crossovers| versus |pathcrossingsps71|
% The |crossovers| function is similar to another tool in the Antarctic
% Mapping Tools package,
% <http://www.mathworks.com/matlabcentral/fileexchange/47638-antarctic-mapping-tools/content/AntarcticMappingTools/Documentation/html/pathcrossingps71_documentation.html |pathcrossingsps71|>.
% Here are the differences: 
% 
% * *|pathcrossingsps71|* finds intersections between two separate
% datasets, say a grounding line and a flight line. |pathcrossingsps71| is preferred when 
% you do not want to find self intersections and/or when data are not
% linked to temporal information. 
% * *|crossovers|* finds self intersections within the same flight line. 
% |crossovers| is more computationally efficient than |pathcrossingsps71| and
% offers options for limiting temporal and spatial separation.   

%% Example: Plot data
% Consider a self-intersecting flight line of ~9000 data points. The Antarctic Mapping Tools package
% includes a sample flight line dataset called |samplegrid|. Let's take a
% look. Start by making a 50 km wide <http://www.mathworks.com/matlabcentral/fileexchange/47282-modis-mosaic-of-antarctica/content//html/modismoa_demo.html |modismoa|>
% map centered on the data points.  Specify low contrast to prevent the background image from being too visually
% busy.  Below I'm using my
% <http://www.mathworks.com/matlabcentral/fileexchange/46872-intuitive-rgb-color-values-from-xkcd/content//demo/html/rgb_demo.html
% |rgb|> function to get RGB values of light blue and dark blue. 

% Load sample data: 
load samplegrid 

% Zoom a map to the region of interest: 
mapzoomps(mean(lat),mean(lon),'mapwidth',50)

% Plot a low-contrast MODIS MOA image: 
modismoaps('contrast','low')

% Plot the flight line: 
plotps(lat,lon,'.','color',rgb('light blue'))

% Add a scalebar: 
scalebarps('length',10)

%% Example: Find all crossover locations
% To find all crossover locations the syntax is easy: 

[latc,lonc] = crossovers(lat,lon); 
plotps(latc,lonc,'o','color',rgb('dark blue'))

%% Example: Limit crossovers to given conditions
% Sometimes you may want to specify conditions for crossovers.  Often times
% we want to filter out processes that take place on short or long time
% scales.  Here let's say we only want crossovers where the different legs 
% of the flight were more than one hour apart and less than 2.5 hours
% apart.  Further, we want to make sure that each crossover location lies
% within 45 meters of a measurement on _each_ leg of the crossover: 

[latc,lonc,zc] = crossovers(lat,lon,z,t,...
    'mindt',1/24,...   % crossovers separated by > 1 hr
    'maxdt',2.5/24,... % crossovers separated by < 2.5 hrs
    'maxdist',45,...   % within 45 m of a measurement   
    'interp','cubic'); % use cubic interpolation

plotps(latc,lonc,'go','markerfacecolor','r')

%% Example: Estimation of errors 
% A common way to quantify measurement errors is to look at the difference
% between measurements at crossover locations.  Above we calculated |zc|, which is a 
% 45x2 matrix of elevations at each of the 45 crossover locations. Column 1 contains elevations
% at crossover locations for the first leg of each crossover and column 2
% contains elevations for the second leg of each crossover. In this example we should expect
% very little change in surface elevation to take place on this grounded
% ice in less than 2.5 hours, so we take the difference between column 1
% and column 2 of |zc| as an estimate of measurement error: 

zerror = zc(:,2)-zc(:,1);

figure
hist(100*abs(zerror),0:10:100)
box off
xlabel 'crossover | \Deltaz | (cm)'
title(['standard deviation of error = ',sprintf('%2.f',std(100*zerror)),' cm'])

%% 
% A standard deviation of 43 cm is pretty close to what we'd expectREPLACE_WITH_DASH_DASHthe
% |samplegrid| data file contains elevations that were obtained by adding
% 40-cm gaussian noise to Bedmap2 data.  

%% Citing AMT
% If this function or any other part of Antarctic Mapping Tools is useful for you, please
% cite the paper that describes AMT.  
% 
% Greene, C. A., Gwyther, D. E., & Blankenship, D. D. Antarctic Mapping Tools for Matlab. 
% _Computers & Geosciences_. 104 (2017) pp.151-157. <http://dx.doi.org/10.1016/j.cageo.2016.08.003 doi:10.1016/j.cageo.2016.08.003>.
% 
%% Author Info: 
% The |crossovers| function, supporting documentation, and the Antarctic Mapping Tools 
% package were written by <http://www.chadagreene Chad A. Greene> of The University of Texas at Austin's Institute for 
% Geophysics, June 2015. This function includes Douglas M. Schwarz's 
% <http://www.mathworks.com/matlabcentral/fileexchange/11837 |intersections|> function as a subfunction.  
##### SOURCE END #####
--></body></html>